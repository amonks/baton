{"name":"Baton","tagline":"tiny javascript library for midi input in the any browser/os with webmidi","body":"# baton.js *v1.0.4*\r\n\r\nbaton.js is a javascript library to make it easy to handle midi input using the newish WebMIDI standard.\r\n\r\n\r\n## webmidi\r\n\r\nWebMIDI is supported in Chrome on OSX, but you have to enable it by visiting [chrome://flags/#enable-web-midi](chrome://flags/#enable-web-midi), clicking `enable`, and relaunching Chrome.\r\n\r\nOn other browsers/OSes, you can use the [WebMIDI API Polyfill](https://github.com/cwilso/WebMIDIAPIShim), which in turn requires the [Jazz-Soft Jazz Plugin](http://jazz-soft.net/).\r\n\r\n\r\n## Examples\r\n\r\nYou can check out the following example files to see how Baton works. Remember to enable the [web-midi flag](chrome://flags/#enable-web-midi) in Chrome.\r\n\r\nThey all require a MIDI source. You can either plug in a controller, or use [MidiKeys](http://www.manyetas.com/creed/midikeys.html)\r\n\r\n*   [use Baton with processing.js](http://baton.monks.co/examples/processing.html) draws velocity-sized circle at note-position\r\n\r\n*   [use Baton to make sound with webPd](http://baton.monks.co/examples/sound.html) plays sine waves\r\n\r\n\r\n## API\r\n\r\n### `callback`\r\n\r\n`callback` stores an optional callback fucntion which is executed when midi input is received.\r\n\r\n    Baton.callback = function(midi) { console.log(midi); };\r\n\r\n### `connect(callback)`\r\n\r\n`connect(callback)` connects Baton to MIDI, and calls an optional callback function once it's connected.\r\n\r\n    Baton.connect( Baton.print() );\r\n\r\n### `check()`\r\n\r\n`check()` returns `true` if Baton has an active midi connection, and `false` if it doesn't.\r\n\r\n### `inputs()`\r\n\r\nIf baton is connected, `inputs()` returns an array of the available midi inputs.\r\n\r\n    Baton.inputs();  # [\"Bus 1\", \"MidiKeys\"]\r\n\r\n### `listen(input)`\r\n\r\nIf baton is connected, `listen(input)` makes it start listening to the given input.\r\n\r\n    // listen to input 0\r\n    Baton.listen(0);\r\n\r\n    // listen to all inputs\r\n    for (var i = 0; i < Baton.inputs().length; i++) {\r\n      Baton.listen(i);\r\n    }\r\n\r\n\r\n## Design Patterns\r\n\r\n### Handle all input sources identically\r\n\r\n[online demo](http://baton.monks.co/examples/single.html)\r\n\r\n    // instantiate object\r\n    baton = new Baton();\r\n\r\n    // create a function to be called once the midi connection is made\r\n    listenMulti = function() {\r\n      // listen to all inputs\r\n      for (var i = 0; i < baton.inputs().length; i++) {\r\n        baton.listen(i);\r\n      }\r\n    };\r\n\r\n\r\n    // connect to midi, set the function to be called when connected\r\n    baton.connect(listenMulti);\r\n\r\n    // this callback is executed when a midi event is received.\r\n    baton.callback = function(m) { console.log(\"multi\", m); };\r\n\r\n### handle specific input sources differently\r\n\r\n[online demo](http://baton.monks.co/examples/multi.html)\r\n\r\n    // instantiate objects\r\n    midiZero = new Baton();\r\n    midiOne = new Baton();\r\n\r\n    // create functions to be called once the midi connections are made\r\n    listenZero = function() { midiZero.listen(0); };\r\n    listenOne = function() { midiOne.listen(1); };\r\n\r\n    // connect to midi, set the functions to be called when connected\r\n    midiZero.connect(listenZero);\r\n    midiOne.connect(listenOne);\r\n\r\n    // these callbacks are executed when a midi event is received.\r\n    midiZero.callback = function(m) { console.log(\"midiZero\", m); };\r\n    midiOne.callback = function(m) { console.log(\"midiOne\", m); };\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
